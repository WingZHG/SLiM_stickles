initialize() {
defineConstant("L", 1e4); // chromosome length

initializeMutationRate(0);
initializeMutationType("m1", 0.5, "f", 0.0); // p1 marker
initializeMutationType("m2", 0.5, "f", 0.0); // p2 marker
initializeMutationType("m3", 0.5, "f", 0.0); // p4 marker
initializeMutationType("m4", 0.5, "f", 0.0); // p4 marker
m1.convertToSubstitution = F;
m2.convertToSubstitution = F;
m3.convertToSubstitution = F;
m4.convertToSubstitution = F;
initializeGenomicElementType("g1", m1, 0);
initializeGenomicElement(g1, 0, L-1);
initializeRecombinationRate(1e-7);
}
1 {
sim.addSubpop("p1", 1000);
sim.addSubpop("p2", 1000);
sim.addSubpop("p3", 1000);
sim.addSubpop("p4", 1000);
}

1 late() {
// p1 and p2 are each fixed for one beneficial mutation
//p1.genomes.addNewDrawnMutation(m1, asInteger(L * 0.2));
//p2.genomes.addNewDrawnMutation(m2, asInteger(L * 0.4));
//p3.genomes.addNewDrawnMutation(m3, asInteger(L * 0.6));
//p4.genomes.addNewDrawnMutation(m4, asInteger(L * 0.8));

// p1 has marker mutations at every position, to track ancestry
p1.genomes.addNewMutation(m1, 0.0, asInteger(L * 0.2));
p2.genomes.addNewMutation(m2, 0.0, asInteger(L * 0.4));
p3.genomes.addNewMutation(m3, 0.0, asInteger(L * 0.6));
p4.genomes.addNewMutation(m4, 0.0, asInteger(L * 0.8));
}
// make p3 be an admixture of p1 and p2 in the next generation
1000 late() {
sim.addSubpop("p5", 1000);
p5.setMigrationRates(c(p1, p2, p3, p4), c(0.25, 0.25, 0.25, 0.25));
}

fitness(m1) {return 1.0;}
fitness(m2) {return 1.0;}
fitness(m3) {return 1.0;}
fitness(m4) {return 1.0;}

modifyChild()
{
// prevent hermaphroditic selfing
if (parent1 == parent2)
 return F;
return T;
} 

1001 late() {
// get rid of p1 and p2
p5.setMigrationRates(c(p1, p2, p3, p4), c(0.0, 0.0, 0.0, 0.0));
p1.setSubpopulationSize(0);
p2.setSubpopulationSize(0);
p3.setSubpopulationSize(0);
p4.setSubpopulationSize(0);
}

1011 late() {

p5g = p5.genomes;

p1Total = sum(p5g.countOfMutationsOfType(m1));
p2Total = sum(p5g.countOfMutationsOfType(m2));
p3Total = sum(p5g.countOfMutationsOfType(m3));
p4Total = sum(p5g.countOfMutationsOfType(m4));
p5Total = p1Total + p2Total + p3Total + p4Total;
print(p1Total);
print(p2Total);
print(p3Total);
print(p4Total);
print(p5Total);

IndHasp1 = (p5.individuals[500].countOfMutationsOfType(m1));
IndHasp2 = (p5.individuals[500].countOfMutationsOfType(m2));
IndHasp3 = (p5.individuals[500].countOfMutationsOfType(m3));
IndHasp4 = (p5.individuals[500].countOfMutationsOfType(m4));

p1Total = IndHasp1;
maxTotal = IndHasp1 + IndHasp2 + IndHasp3 + IndHasp4;
p1TotalFraction = p1Total / maxTotal;

p2Total = IndHasp2;
p2TotalFraction = p2Total / maxTotal;

p3Total = IndHasp3;
p3TotalFraction = p3Total / maxTotal;

p4Total = IndHasp4;
p4TotalFraction = p4Total / maxTotal;

print(p1Total);
print(p2Total);
print(p3Total);
print(p4Total);

print(p1TotalFraction);
print(p2TotalFraction);
print(p3TotalFraction);
print(p4TotalFraction);
//print(p5g.positionsOfMutationsOfType(m4));

sim.simulationFinished();
}