initialize() {
defineConstant("L", 1e4); // chromosome length

initializeMutationRate(0);
initializeMutationType("m1", 0.5, "f", 0.1); // p1 marker
initializeMutationType("m2", 0.5, "f", 0.0); // p2 marker
initializeMutationType("m3", 0.5, "f", 0.0); // p4 marker
initializeMutationType("m4", 0.5, "f", 0.0); // p4 marker
m1.convertToSubstitution = F;
m2.convertToSubstitution = F;
m3.convertToSubstitution = F;
m4.convertToSubstitution = F;
initializeGenomicElementType("g1", m1, 0);
initializeGenomicElement(g1, 0, L-1);
initializeRecombinationRate(1e-7);
}
1 {
sim.addSubpop("p1", 2000);
sim.addSubpop("p2", 2000);
sim.addSubpop("p3", 2000);
sim.addSubpop("p4", 2000);
}

1 late() {
// p1 and p2 are each fixed for one beneficial mutation
//p1.genomes.addNewDrawnMutation(m1, asInteger(L * 0.2));
//p2.genomes.addNewDrawnMutation(m2, asInteger(L * 0.4));
//p3.genomes.addNewDrawnMutation(m3, asInteger(L * 0.6));
//p4.genomes.addNewDrawnMutation(m4, asInteger(L * 0.8));

// p1 has marker mutations at every position, to track ancestry
p1.genomes.addNewMutation(m1, 0.0, asInteger(L * 0.2));
p2.genomes.addNewMutation(m2, 0.0, asInteger(L * 0.4));
p3.genomes.addNewMutation(m3, 0.0, asInteger(L * 0.6));
p4.genomes.addNewMutation(m4, 0.0, asInteger(L * 0.8));

// make p3 be an admixture of p1 and p2 in the next generation
sim.addSubpop("p5", 2000);
p5.setMigrationRates(c(p1, p2, p3, p4), c(0.25, 0.25, 0.25, 0.25));
}
2 late() {
// get rid of p1 and p2
p5.setMigrationRates(c(p1, p2, p3, p4), c(0.0, 0.0, 0.0, 0.0));
p1.setSubpopulationSize(0);
p2.setSubpopulationSize(0);
p3.setSubpopulationSize(0);
p4.setSubpopulationSize(0);
}
10 late() {

p5g = p5.genomes;

p1Total = sum(p5g.countOfMutationsOfType(m1));
p2Total = sum(p5g.countOfMutationsOfType(m2));
p3Total = sum(p5g.countOfMutationsOfType(m3));
p4Total = sum(p5g.countOfMutationsOfType(m4));
p5Total = p1Total + p2Total + p3Total + p4Total;
print(p1Total);
print(p2Total);
print(p3Total);
print(p4Total);
print(p5Total);
 

sim.simulationFinished();
}